"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTextOffsetByRadius = getTextOffsetByRadius;
exports.formatTextLabelData = exports.textLabelAccessor = exports.defaultPadding = void 0;

var _viewportMercatorProject = require("viewport-mercator-project");

var _dataUtils = require("../utils/data-utils");

var _lodash = _interopRequireDefault(require("lodash.uniq"));

// Copyright (c) 2022 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
var defaultPadding = 20;
exports.defaultPadding = defaultPadding;

function getTextOffsetByRadius(radiusScale, getRadius, mapState) {
  return function (textLabel) {
    var distanceScale = (0, _viewportMercatorProject.getDistanceScales)(mapState);
    var xMult = textLabel.anchor === 'middle' ? 0 : textLabel.anchor === 'start' ? 1 : -1;
    var yMult = textLabel.alignment === 'center' ? 0 : textLabel.alignment === 'bottom' ? 1 : -1;
    var sizeOffset = textLabel.alignment === 'center' ? 0 : textLabel.alignment === 'bottom' ? textLabel.size : textLabel.size;
    var pixelRadius = radiusScale * distanceScale.pixelsPerMeter[0];
    var padding = defaultPadding;
    return typeof getRadius === 'function' ? function (d) {
      return [xMult * (getRadius(d) * pixelRadius + padding), yMult * (getRadius(d) * pixelRadius + padding + sizeOffset)];
    } : [xMult * (getRadius * pixelRadius + padding), yMult * (getRadius * pixelRadius + padding + sizeOffset)];
  };
}

var textLabelAccessor = function textLabelAccessor(textLabel) {
  return function (dc) {
    return function (d) {
      var val = textLabel.field.valueAccessor(d);
      return (0, _dataUtils.notNullorUndefined)(val) ? String(val) : '';
    };
  };
};

exports.textLabelAccessor = textLabelAccessor;

var formatTextLabelData = function formatTextLabelData(_ref) {
  var textLabel = _ref.textLabel,
      triggerChanged = _ref.triggerChanged,
      oldLayerData = _ref.oldLayerData,
      data = _ref.data,
      dataContainer = _ref.dataContainer;
  return textLabel.map(function (tl, i) {
    if (!tl.field) {
      // if no field selected,
      return {
        getText: null,
        characterSet: []
      };
    }

    var getText = textLabelAccessor(tl)(dataContainer);
    var characterSet;

    if (!triggerChanged["getLabelCharacterSet-".concat(i)] && oldLayerData && oldLayerData.textLabels && oldLayerData.textLabels[i]) {
      characterSet = oldLayerData.textLabels[i].characterSet;
    } else {
      var allLabels = tl.field ? data.map(getText) : [];
      characterSet = (0, _lodash["default"])(allLabels.join(''));
    }

    return {
      characterSet: characterSet,
      getText: getText
    };
  });
};

exports.formatTextLabelData = formatTextLabelData;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYXllcnMvbGF5ZXItdGV4dC1sYWJlbC5qcyJdLCJuYW1lcyI6WyJkZWZhdWx0UGFkZGluZyIsImdldFRleHRPZmZzZXRCeVJhZGl1cyIsInJhZGl1c1NjYWxlIiwiZ2V0UmFkaXVzIiwibWFwU3RhdGUiLCJ0ZXh0TGFiZWwiLCJkaXN0YW5jZVNjYWxlIiwieE11bHQiLCJhbmNob3IiLCJ5TXVsdCIsImFsaWdubWVudCIsInNpemVPZmZzZXQiLCJzaXplIiwicGl4ZWxSYWRpdXMiLCJwaXhlbHNQZXJNZXRlciIsInBhZGRpbmciLCJkIiwidGV4dExhYmVsQWNjZXNzb3IiLCJkYyIsInZhbCIsImZpZWxkIiwidmFsdWVBY2Nlc3NvciIsIlN0cmluZyIsImZvcm1hdFRleHRMYWJlbERhdGEiLCJ0cmlnZ2VyQ2hhbmdlZCIsIm9sZExheWVyRGF0YSIsImRhdGEiLCJkYXRhQ29udGFpbmVyIiwibWFwIiwidGwiLCJpIiwiZ2V0VGV4dCIsImNoYXJhY3RlclNldCIsInRleHRMYWJlbHMiLCJhbGxMYWJlbHMiLCJqb2luIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBb0JBOztBQUNBOztBQUNBOztBQXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1PLElBQU1BLGNBQWMsR0FBRyxFQUF2Qjs7O0FBRUEsU0FBU0MscUJBQVQsQ0FBK0JDLFdBQS9CLEVBQTRDQyxTQUE1QyxFQUF1REMsUUFBdkQsRUFBaUU7QUFDdEUsU0FBTyxVQUFBQyxTQUFTLEVBQUk7QUFDbEIsUUFBTUMsYUFBYSxHQUFHLGdEQUFrQkYsUUFBbEIsQ0FBdEI7QUFDQSxRQUFNRyxLQUFLLEdBQUdGLFNBQVMsQ0FBQ0csTUFBVixLQUFxQixRQUFyQixHQUFnQyxDQUFoQyxHQUFvQ0gsU0FBUyxDQUFDRyxNQUFWLEtBQXFCLE9BQXJCLEdBQStCLENBQS9C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QUNEOztBQUVELFdBQU87QUFDTEgsTUFBQUEsWUFBWSxFQUFaQSxZQURLO0FBRUxELE1BQUFBLE9BQU8sRUFBUEE7QUFGSyxLQUFQO0FBSUQsR0E1Qk0sQ0FBUDtBQTZCRCxDQXBDTSIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7Z2V0RGlzdGFuY2VTY2FsZXN9IGZyb20gJ3ZpZXdwb3J0LW1lcmNhdG9yLXByb2plY3QnO1xuaW1wb3J0IHtub3ROdWxsb3JVbmRlZmluZWR9IGZyb20gJ3V0aWxzL2RhdGEtdXRpbHMnO1xuaW1wb3J0IHVuaXEgZnJvbSAnbG9kYXNoLnVuaXEnO1xuXG5leHBvcnQgY29uc3QgZGVmYXVsdFBhZGRpbmcgPSAyMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHRPZmZzZXRCeVJhZGl1cyhyYWRpdXNTY2FsZSwgZ2V0UmFkaXVzLCBtYXBTdGF0ZSkge1xuICByZXR1cm4gdGV4dExhYmVsID0+IHtcbiAgICBjb25zdCBkaXN0YW5jZVNjYWxlID0gZ2V0RGlzdGFuY2VTY2FsZXMobWFwU3RhdGUpO1xuICAgIGNvbnN0IHhNdWx0ID0gdGV4dExhYmVsLmFuY2hvciA9PT0gJ21pZGRsZScgPyAwIDogdGV4dExhYmVsLmFuY2hvciA9PT0gJ3N0YXJ0JyA/IDEgOiAtMTtcbiAgICBjb25zdCB5TXVsdCA9IHRleHRMYWJlbC5hbGlnbm1lbnQgPT09ICdjZW50ZXInID8gMCA6IHRleHRMYWJlbC5hbGlnbm1lbnQgPT09ICdib3R0b20nID8gMSA6IC0xO1xuXG4gICAgY29uc3Qgc2l6ZU9mZnNldCA9XG4gICAgICB0ZXh0TGFiZWwuYWxpZ25tZW50ID09PSAnY2VudGVyJ1xuICAgICAgICA/IDBcbiAgICAgICAgOiB0ZXh0TGFiZWwuYWxpZ25tZW50ID09PSAnYm90dG9tJ1xuICAgICAgICA/IHRleHRMYWJlbC5zaXplXG4gICAgICAgIDogdGV4dExhYmVsLnNpemU7XG5cbiAgICBjb25zdCBwaXhlbFJhZGl1cyA9IHJhZGl1c1NjYWxlICogZGlzdGFuY2VTY2FsZS5waXhlbHNQZXJNZXRlclswXTtcbiAgICBjb25zdCBwYWRkaW5nID0gZGVmYXVsdFBhZGRpbmc7XG5cbiAgICByZXR1cm4gdHlwZW9mIGdldFJhZGl1cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBkID0+IFtcbiAgICAgICAgICB4TXVsdCAqIChnZXRSYWRpdXMoZCkgKiBwaXhlbFJhZGl1cyArIHBhZGRpbmcpLFxuICAgICAgICAgIHlNdWx0ICogKGdldFJhZGl1cyhkKSAqIHBpeGVsUmFkaXVzICsgcGFkZGluZyArIHNpemVPZmZzZXQpXG4gICAgICAgIF1cbiAgICAgIDogW1xuICAgICAgICAgIHhNdWx0ICogKGdldFJhZGl1cyAqIHBpeGVsUmFkaXVzICsgcGFkZGluZyksXG4gICAgICAgICAgeU11bHQgKiAoZ2V0UmFkaXVzICogcGl4ZWxSYWRpdXMgKyBwYWRkaW5nICsgc2l6ZU9mZnNldClcbiAgICAgICAgXTtcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHRleHRMYWJlbEFjY2Vzc29yID0gdGV4dExhYmVsID0+IGRjID0+IGQgPT4ge1xuICBjb25zdCB2YWwgPSB0ZXh0TGFiZWwuZmllbGQudmFsdWVBY2Nlc3NvcihkKTtcbiAgcmV0dXJuIG5vdE51bGxvclVuZGVmaW5lZCh2YWwpID8gU3RyaW5nKHZhbCkgOiAnJztcbn07XG5cbmV4cG9ydCBjb25zdCBmb3JtYXRUZXh0TGFiZWxEYXRhID0gKHtcbiAgdGV4dExhYmVsLFxuICB0cmlnZ2VyQ2hhbmdlZCxcbiAgb2xkTGF5ZXJEYXRhLFxuICBkYXRhLFxuICBkYXRhQ29udGFpbmVyXG59KSA9PiB7XG4gIHJldHVybiB0ZXh0TGFiZWwubWFwKCh0bCwgaSkgPT4ge1xuICAgIGlmICghdGwuZmllbGQpIHtcbiAgICAgIC8vIGlmIG5vIGZpZWxkIHNlbGVjdGVkLFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0VGV4dDogbnVsbCxcbiAgICAgICAgY2hhcmFjdGVyU2V0OiBbXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBnZXRUZXh0ID0gdGV4dExhYmVsQWNjZXNzb3IodGwpKGRhdGFDb250YWluZXIpO1xuICAgIGxldCBjaGFyYWN0ZXJTZXQ7XG5cbiAgICBpZiAoXG4gICAgICAhdHJpZ2dlckNoYW5nZWRbYGdldExhYmVsQ2hhcmFjdGVyU2V0LSR7aX1gXSAmJlxuICAgICAgb2xkTGF5ZXJEYXRhICYmXG4gICAgICBvbGRMYXllckRhdGEudGV4dExhYmVscyAmJlxuICAgICAgb2xkTGF5ZXJEYXRhLnRleHRMYWJlbHNbaV1cbiAgICApIHtcbiAgICAgIGNoYXJhY3RlclNldCA9IG9sZExheWVyRGF0YS50ZXh0TGFiZWxzW2ldLmNoYXJhY3RlclNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWxsTGFiZWxzID0gdGwuZmllbGQgPyBkYXRhLm1hcChnZXRUZXh0KSA6IFtdO1xuICAgICAgY2hhcmFjdGVyU2V0ID0gdW5pcShhbGxMYWJlbHMuam9pbignJykpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjaGFyYWN0ZXJTZXQsXG4gICAgICBnZXRUZXh0XG4gICAgfTtcbiAgfSk7XG59O1xuIl19