"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderedSize = renderedSize;
exports.adjustCellsToContainer = adjustCellsToContainer;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _document = _interopRequireDefault(require("global/document"));

var _dataUtils = require("../../../utils/data-utils");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var MIN_GHOST_CELL_SIZE = 200;
/**
 * Measure rows and column content to determine min width for each column
 * @param {*} param0
 */

function renderedSize(_ref) {
  var _ref$text = _ref.text,
      dataContainer = _ref$text.dataContainer,
      column = _ref$text.column,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'string' : _ref$type,
      colIdx = _ref.colIdx,
      _ref$numRowsToCalcula = _ref.numRowsToCalculate,
      numRowsToCalculate = _ref$numRowsToCalcula === void 0 ? 10 : _ref$numRowsToCalcula,
      _ref$fontSize = _ref.fontSize,
      fontSize = _ref$fontSize === void 0 ? 12 : _ref$fontSize,
      _ref$font = _ref.font,
      font = _ref$font === void 0 ? 'Lato' : _ref$font,
      _ref$cellPadding = _ref.cellPadding,
      cellPadding = _ref$cellPadding === void 0 ? 40 : _ref$cellPadding,
      _ref$maxCellSize = _ref.maxCellSize,
      maxCellSize = _ref$maxCellSize === void 0 ? 400 : _ref$maxCellSize,
      _ref$maxHeaderSize = _ref.maxHeaderSize,
      maxHeaderSize = _ref$maxHeaderSize === void 0 ? 150 : _ref$maxHeaderSize,
      _ref$minCellSize = _ref.minCellSize,
      minCellSize = _ref$minCellSize === void 0 ? 45 : _ref$minCellSize,
      _ref$optionsButton = _ref.optionsButton,
      optionsButton = _ref$optionsButton === void 0 ? 30 : _ref$optionsButton;

  if (!_document["default"]) {
    return {
      row: 0,
      header: 0
    };
  }

  var textCanvas = _document["default"].createElement('canvas');

  _document["default"].body.appendChild(textCanvas);

  var context = textCanvas.getContext('2d');
  context.font = [fontSize, font].join('px ');
  var rowsToSample = (0, _toConsumableArray2["default"])(Array(numRowsToCalculate)).map(function () {
    return Math.floor(Math.random() * (dataContainer.numRows() - 1));
  }); // If we have less than 10 rows, lets measure all of them

  if (dataContainer.numRows() <= numRowsToCalculate) {
    rowsToSample = Array.from(Array(dataContainer.numRows()).keys());
  }

  var rowWidth = Math.max.apply(Math, (0, _toConsumableArray2["default"])(rowsToSample.map(function (rowIdx) {
    return Math.ceil(context.measureText((0, _dataUtils.parseFieldValue)(dataContainer.valueAt(rowIdx, colIdx), type)).width) + cellPadding;
  }))); // header cell only has left padding

  var headerWidth = Math.ceil(context.measureText(column).width) + cellPadding / 2 + optionsButton;
  var minRowWidth = minCellSize + cellPadding;
  var minHeaderWidth = minCellSize + cellPadding / 2 + optionsButton;
  var clampedRowWidth = clamp(minRowWidth, maxCellSize, rowWidth);
  var clampedHeaderWidth = clamp(minHeaderWidth, maxHeaderSize, headerWidth); // cleanup

  textCanvas.parentElement.removeChild(textCanvas);
  return {
    row: clampedRowWidth,
    header: clampedHeaderWidth
  };
}

function clamp(min, max, value) {
  return Math.max(Math.min(max, value), min);
}

function getColumnOrder() {
  var pinnedColumns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var unpinnedColumns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return [].concat((0, _toConsumableArray2["default"])(pinnedColumns), (0, _toConsumableArray2["default"])(unpinnedColumns));
}

function getMinCellSize(cellSizeCache) {
  return Object.keys(cellSizeCache).reduce(function (accu, col) {
    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, col, cellSizeCache[col].row));
  }, {});
}

function getSizeSum(sizeCache, key) {
  return Object.keys(sizeCache).reduce(function (acc, val) {
    return acc + (key ? sizeCache[val][key] : sizeCache[val]);
  }, 0);
}
/**
 * Expand cell to fit both row and header, if there is still room left,
 * expand last cell to fit the entire width of the container
 * @param {object} cellSizeCache
 * @param {string[]} columnOrder
 * @param {number} containerWidth
 * @param {number} roomToFill
 */


function expandCellSize(cellSizeCache, columnOrder, containerWidth, roomToFill) {
  var remaining = roomToFill;
  var expandedCellSize = columnOrder.reduce(function (accu, col) {
    var size = cellSizeCache[col].row;

    if (cellSizeCache[col].row < cellSizeCache[col].header && remaining > 0) {
      // if we are cutting off the header, expand to fit it
      size = cellSizeCache[col].header - cellSizeCache[col].row < remaining ? cellSizeCache[col].header : cellSizeCache[col].row + remaining;
      remaining -= size - cellSizeCache[col].row;
    }

    return _objectSpread(_objectSpread({}, accu), {}, (0, _defineProperty2["default"])({}, col, size));
  }, {});
  var ghost = null;

  if (remaining > 0 && remaining < MIN_GHOST_CELL_SIZE) {
    // expand last cell
    var lastCell = columnOrder[columnOrder.length - 1];
    expandedCellSize[lastCell] += remaining;
  } else if (remaining >= MIN_GHOST_CELL_SIZE) {
    // if too much left add a ghost cell
    ghost = remaining;
  }

  return {
    cellSizeCache: expandedCellSize,
    ghost: ghost
  };
}
/**
 * Adjust cell size based on container width
 * @param {number} containerWidth
 * @param {Object} cellSizeCache
 * @param {string[]} pinnedColumns
 * @param {string[]} unpinnedColumns
 */


function adjustCellsToContainer(containerWidth, cellSizeCache, pinnedColumns, unpinnedColumns) {
  var minRowSum = getSizeSum(cellSizeCache, 'row');

  if (minRowSum >= containerWidth) {
    // we apply the min Width to all cells
    return {
      cellSizeCache: getMinCellSize(cellSizeCache)
    };
  } // if we have some room to expand


  var columnOrder = getColumnOrder(pinnedColumns, unpinnedColumns);
  return expandCellSize(cellSizeCache, columnOrder, containerWidth, containerWidth - minRowSum);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL2NvbW1vbi9kYXRhLXRhYmxlL2NlbGwtc2l6ZS5qcyJdLCJuYW1lcyI6WyJNSU5fR0hPU1RfQ0VMTF9TSVpFIiwicmVuZGVyZWRTaXplIiwidGV4dCIsImRhdGFDb250YWluZXIiLCJjb2x1bW4iLCJ0eXBlIiwiY29sSWR4IiwibnVtUm93c1RvQ2FsY3VsYXRlIiwiZm9udFNpemUiLCJmb250IiwiY2VsbFBhZGRpbmciLCJtYXhDZWxsU2l6ZSIsIm1heEhlYWRlclNpemUiLCJtaW5DZWxsU2l6ZSIsIm9wdGlvbnNCdXR0b24iLCJkb2N1bWVudCIsInJvdyIsImhlYWRlciIsInRleHRDYW52YXMiLCJjcmVhdGVFbGVtZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwiY29udGV4dCIsImdldENvbnRleHQiLCJqb2luIiwicm93c1RvU2FtcGxlIiwiQXJyYXkiLCJtYXAiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJudW1Sb3dzIiwiZnJvbSIsImtleXMiLCJyb3dXaWR0aCIsIm1heCIsInJvd0lkeCIsImNlaWwiLCJtZWFzdXJlVGV4dCIsInZhbHVlQXQiLCJ3aWR0aCIsImhlYWRlcldpZHRoIiwibWluUm93V2lkdGgiLCJtaW5IZWFkZXJXaWR0aCIsImNsYW1wZWRSb3dXaWR0aCIsImNsYW1wIiwiY2xhbXBlZEhlYWRlcldpZHRoIiwicGFyZW50RWxlbWVudCIsInJlbW92ZUNoaWxkIiwibWluIiwidmFsdWUiLCJnZXRDb2x1bW5PcmRlciIsInBpbm5lZENvbHVtbnMiLCJ1bnBpbm5lZENvbHVtbnMiLCJnZXRNaW5DZWxsU2l6ZSIsImNlbGxTaXplQ2FjaGUiLCJPYmplY3QiLCJyZWR1Y2UiLCJhY2N1IiwiY29sIiwiZ2V0U2l6ZVN1bSIsInNpemVDYWNoZSIsImtleSIsImFjYyIsInZhbCIsImV4cGFuZENlbGxTaXplIiwiY29sdW1uT3JkZXIiLCJjb250YWluZXJXaWR0aCIsInJvb21Ub0ZpbGwiLCJyZW1haW5pbmciLCJleHBhbmRlZENlbGxTaXplIiwic2l6ZSIsImdob3N0IiwibGFzdENlbGwiLCJsZW5ndGgiLCJhZGp1c3RDZWxsc1RvQ29udGFpbmVyIiwibWluUm93U3VtIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsbUJBQW1CLEdBQUcsR0FBNUI7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDTyxTQUFTQyxZQUFULE9BWUo7QUFBQSx1QkFYREMsSUFXQztBQUFBLE1BWE1DLGFBV04sYUFYTUEsYUFXTjtBQUFBLE1BWHFCQyxNQVdyQixhQVhxQkEsTUFXckI7QUFBQSx1QkFWREMsSUFVQztBQUFBLE1BVkRBLElBVUMsMEJBVk0sUUFVTjtBQUFBLE1BVERDLE1BU0MsUUFUREEsTUFTQztBQUFBLG1DQVJEQyxrQkFRQztBQUFBLE1BUkRBLGtCQVFDLHNDQVJvQixFQVFwQjtBQUFBLDJCQVBEQyxRQU9DO0FBQUEsTUFQREEsUUFPQyw4QkFQVSxFQU9WO0FBQUEsdUJBTkRDLElBTUM7QUFBQSxNQU5EQSxJQU1DLDBCQU5NLE1BTU47QUFBQSw4QkFMREMsV0FLQztBQUFBLE1BTERBLFdBS0MsaUNBTGEsRUFLYjtBQUFBLDhCQUpEQyxXQUlDO0FBQUEsTUFKREEsV0FJQyxpQ0FKYSxHQUliO0FBQUEsZ0NBSERDLGFBR0M7QUFBQSxNQUhEQSxhQUdDLG1DQUhlLEdBR2Y7QUFBQSw4QkFGREMsV0FFQztBQUFBLE1BRkRBLFdBRUMsaUNBRmEsRUFFYjtBQUFBLGdDQUREQyxhQUNDO0FBQUEsTUFEREEsYUFDQyxtQ0FEZSxFQUNmOztBQUNELE1BQUksQ0FBQ0Msb0JBQUwsRUFBZTtBQUNiLFdBQU87QUFDTEMsTUFBQUEsR0FBRyxFQUFFLENBREE7QUFFTEMsTUFBQUEsTUFBTSxFQUFFO0FBRkgsS0FBUDtBQUlEOztBQUNELE1BQU1DLFVBQVUsR0FBR0gscUJBQVNJLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBbkI7O0FBQ0FKLHVCQUFTSyxJQUFULENBQWNDLFdBQWQs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V0FBaEIsRUFBNkJDLGNBQTdCLEVBQTZDQSxjQUFjLEdBQUdTLFNBQTlELENBQXJCO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMjIgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQgZG9jdW1lbnQgZnJvbSAnZ2xvYmFsL2RvY3VtZW50JztcbmltcG9ydCB7cGFyc2VGaWVsZFZhbHVlfSBmcm9tICd1dGlscy9kYXRhLXV0aWxzJztcblxuY29uc3QgTUlOX0dIT1NUX0NFTExfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBNZWFzdXJlIHJvd3MgYW5kIGNvbHVtbiBjb250ZW50IHRvIGRldGVybWluZSBtaW4gd2lkdGggZm9yIGVhY2ggY29sdW1uXG4gKiBAcGFyYW0geyp9IHBhcmFtMFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyZWRTaXplKHtcbiAgdGV4dDoge2RhdGFDb250YWluZXIsIGNvbHVtbn0sXG4gIHR5cGUgPSAnc3RyaW5nJyxcbiAgY29sSWR4LFxuICBudW1Sb3dzVG9DYWxjdWxhdGUgPSAxMCxcbiAgZm9udFNpemUgPSAxMixcbiAgZm9udCA9ICdMYXRvJyxcbiAgY2VsbFBhZGRpbmcgPSA0MCxcbiAgbWF4Q2VsbFNpemUgPSA0MDAsXG4gIG1heEhlYWRlclNpemUgPSAxNTAsXG4gIG1pbkNlbGxTaXplID0gNDUsXG4gIG9wdGlvbnNCdXR0b24gPSAzMFxufSkge1xuICBpZiAoIWRvY3VtZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdzogMCxcbiAgICAgIGhlYWRlcjogMFxuICAgIH07XG4gIH1cbiAgY29uc3QgdGV4dENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRleHRDYW52YXMpO1xuICBjb25zdCBjb250ZXh0ID0gdGV4dENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjb250ZXh0LmZvbnQgPSBbZm9udFNpemUsIGZvbnRdLmpvaW4oJ3B4ICcpO1xuXG4gIGxldCByb3dzVG9TYW1wbGUgPSBbLi4uQXJyYXkobnVtUm93c1RvQ2FsY3VsYXRlKV0ubWFwKCgpID0+XG4gICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGRhdGFDb250YWluZXIubnVtUm93cygpIC0gMSkpXG4gICk7XG5cbiAgLy8gSWYgd2UgaGF2ZSBsZXNzIHRoYW4gMTAgcm93cywgbGV0cyBtZWFzdXJlIGFsbCBvZiB0aGVtXG4gIGlmIChkYXRhQ29udGFpbmVyLm51bVJvd3MoKSA8PSBudW1Sb3dzVG9DYWxjdWxhdGUpIHtcbiAgICByb3dzVG9TYW1wbGUgPSBBcnJheS5mcm9tKEFycmF5KGRhdGFDb250YWluZXIubnVtUm93cygpKS5rZXlzKCkpO1xuICB9XG4gIGNvbnN0IHJvd1dpZHRoID0gTWF0aC5tYXgoXG4gICAgLi4ucm93c1RvU2FtcGxlLm1hcChcbiAgICAgIHJvd0lkeCA9PlxuICAgICAgICBNYXRoLmNlaWwoXG4gICAgICAgICAgY29udGV4dC5tZWFzdXJlVGV4dChwYXJzZUZpZWxkVmFsdWUoZGF0YUNvbnRhaW5lci52YWx1ZUF0KHJvd0lkeCwgY29sSWR4KSwgdHlwZSkpLndpZHRoXG4gICAgICAgICkgKyBjZWxsUGFkZGluZ1xuICAgIClcbiAgKTtcbiAgLy8gaGVhZGVyIGNlbGwgb25seSBoYXMgbGVmdCBwYWRkaW5nXG4gIGNvbnN0IGhlYWRlcldpZHRoID1cbiAgICBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dChjb2x1bW4pLndpZHRoKSArIGNlbGxQYWRkaW5nIC8gMiArIG9wdGlvbnNCdXR0b247XG5cbiAgY29uc3QgbWluUm93V2lkdGggPSBtaW5DZWxsU2l6ZSArIGNlbGxQYWRkaW5nO1xuICBjb25zdCBtaW5IZWFkZXJXaWR0aCA9IG1pbkNlbGxTaXplICsgY2VsbFBhZGRpbmcgLyAyICsgb3B0aW9uc0J1dHRvbjtcblxuICBjb25zdCBjbGFtcGVkUm93V2lkdGggPSBjbGFtcChtaW5Sb3dXaWR0aCwgbWF4Q2VsbFNpemUsIHJvd1dpZHRoKTtcbiAgY29uc3QgY2xhbXBlZEhlYWRlcldpZHRoID0gY2xhbXAobWluSGVhZGVyV2lkdGgsIG1heEhlYWRlclNpemUsIGhlYWRlcldpZHRoKTtcblxuICAvLyBjbGVhbnVwXG4gIHRleHRDYW52YXMucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0ZXh0Q2FudmFzKTtcblxuICByZXR1cm4ge1xuICAgIHJvdzogY2xhbXBlZFJvd1dpZHRoLFxuICAgIGhlYWRlcjogY2xhbXBlZEhlYWRlcldpZHRoXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obWF4LCB2YWx1ZSksIG1pbik7XG59XG5cbmZ1bmN0aW9uIGdldENvbHVtbk9yZGVyKHBpbm5lZENvbHVtbnMgPSBbXSwgdW5waW5uZWRDb2x1bW5zID0gW10pIHtcbiAgcmV0dXJuIFsuLi5waW5uZWRDb2x1bW5zLCAuLi51bnBpbm5lZENvbHVtbnNdO1xufVxuXG5mdW5jdGlvbiBnZXRNaW5DZWxsU2l6ZShjZWxsU2l6ZUNhY2hlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhjZWxsU2l6ZUNhY2hlKS5yZWR1Y2UoXG4gICAgKGFjY3UsIGNvbCkgPT4gKHtcbiAgICAgIC4uLmFjY3UsXG4gICAgICBbY29sXTogY2VsbFNpemVDYWNoZVtjb2xdLnJvd1xuICAgIH0pLFxuICAgIHt9XG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemVTdW0oc2l6ZUNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNpemVDYWNoZSkucmVkdWNlKFxuICAgIChhY2MsIHZhbCkgPT4gYWNjICsgKGtleSA/IHNpemVDYWNoZVt2YWxdW2tleV0gOiBzaXplQ2FjaGVbdmFsXSksXG4gICAgMFxuICApO1xufVxuXG4vKipcbiAqIEV4cGFuZCBjZWxsIHRvIGZpdCBib3RoIHJvdyBhbmQgaGVhZGVyLCBpZiB0aGVyZSBpcyBzdGlsbCByb29tIGxlZnQsXG4gKiBleHBhbmQgbGFzdCBjZWxsIHRvIGZpdCB0aGUgZW50aXJlIHdpZHRoIG9mIHRoZSBjb250YWluZXJcbiAqIEBwYXJhbSB7b2JqZWN0fSBjZWxsU2l6ZUNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBjb2x1bW5PcmRlclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbnRhaW5lcldpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gcm9vbVRvRmlsbFxuICovXG5mdW5jdGlvbiBleHBhbmRDZWxsU2l6ZShjZWxsU2l6ZUNhY2hlLCBjb2x1bW5PcmRlciwgY29udGFpbmVyV2lkdGgsIHJvb21Ub0ZpbGwpIHtcbiAgbGV0IHJlbWFpbmluZyA9IHJvb21Ub0ZpbGw7XG5cbiAgY29uc3QgZXhwYW5kZWRDZWxsU2l6ZSA9IGNvbHVtbk9yZGVyLnJlZHVjZSgoYWNjdSwgY29sKSA9PiB7XG4gICAgbGV0IHNpemUgPSBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93O1xuICAgIGlmIChjZWxsU2l6ZUNhY2hlW2NvbF0ucm93IDwgY2VsbFNpemVDYWNoZVtjb2xdLmhlYWRlciAmJiByZW1haW5pbmcgPiAwKSB7XG4gICAgICAvLyBpZiB3ZSBhcmUgY3V0dGluZyBvZmYgdGhlIGhlYWRlciwgZXhwYW5kIHRvIGZpdCBpdFxuICAgICAgc2l6ZSA9XG4gICAgICAgIGNlbGxTaXplQ2FjaGVbY29sXS5oZWFkZXIgLSBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93IDwgcmVtYWluaW5nXG4gICAgICAgICAgPyBjZWxsU2l6ZUNhY2hlW2NvbF0uaGVhZGVyXG4gICAgICAgICAgOiBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93ICsgcmVtYWluaW5nO1xuICAgICAgcmVtYWluaW5nIC09IHNpemUgLSBjZWxsU2l6ZUNhY2hlW2NvbF0ucm93O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2N1LFxuICAgICAgW2NvbF06IHNpemVcbiAgICB9O1xuICB9LCB7fSk7XG5cbiAgbGV0IGdob3N0ID0gbnVsbDtcbiAgaWYgKHJlbWFpbmluZyA+IDAgJiYgcmVtYWluaW5nIDwgTUlOX0dIT1NUX0NFTExfU0laRSkge1xuICAgIC8vIGV4cGFuZCBsYXN0IGNlbGxcbiAgICBjb25zdCBsYXN0Q2VsbCA9IGNvbHVtbk9yZGVyW2NvbHVtbk9yZGVyLmxlbmd0aCAtIDFdO1xuICAgIGV4cGFuZGVkQ2VsbFNpemVbbGFzdENlbGxdICs9IHJlbWFpbmluZztcbiAgfSBlbHNlIGlmIChyZW1haW5pbmcgPj0gTUlOX0dIT1NUX0NFTExfU0laRSkge1xuICAgIC8vIGlmIHRvbyBtdWNoIGxlZnQgYWRkIGEgZ2hvc3QgY2VsbFxuICAgIGdob3N0ID0gcmVtYWluaW5nO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjZWxsU2l6ZUNhY2hlOiBleHBhbmRlZENlbGxTaXplLFxuICAgIGdob3N0XG4gIH07XG59XG5cbi8qKlxuICogQWRqdXN0IGNlbGwgc2l6ZSBiYXNlZCBvbiBjb250YWluZXIgd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb250YWluZXJXaWR0aFxuICogQHBhcmFtIHtPYmplY3R9IGNlbGxTaXplQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBpbm5lZENvbHVtbnNcbiAqIEBwYXJhbSB7c3RyaW5nW119IHVucGlubmVkQ29sdW1uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRqdXN0Q2VsbHNUb0NvbnRhaW5lcihcbiAgY29udGFpbmVyV2lkdGgsXG4gIGNlbGxTaXplQ2FjaGUsXG4gIHBpbm5lZENvbHVtbnMsXG4gIHVucGlubmVkQ29sdW1uc1xuKSB7XG4gIGNvbnN0IG1pblJvd1N1bSA9IGdldFNpemVTdW0oY2VsbFNpemVDYWNoZSwgJ3JvdycpO1xuICBpZiAobWluUm93U3VtID49IGNvbnRhaW5lcldpZHRoKSB7XG4gICAgLy8gd2UgYXBwbHkgdGhlIG1pbiBXaWR0aCB0byBhbGwgY2VsbHNcbiAgICByZXR1cm4ge2NlbGxTaXplQ2FjaGU6IGdldE1pbkNlbGxTaXplKGNlbGxTaXplQ2FjaGUpfTtcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgc29tZSByb29tIHRvIGV4cGFuZFxuICBjb25zdCBjb2x1bW5PcmRlciA9IGdldENvbHVtbk9yZGVyKHBpbm5lZENvbHVtbnMsIHVucGlubmVkQ29sdW1ucyk7XG4gIHJldHVybiBleHBhbmRDZWxsU2l6ZShjZWxsU2l6ZUNhY2hlLCBjb2x1bW5PcmRlciwgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lcldpZHRoIC0gbWluUm93U3VtKTtcbn1cbiJdfQ==