"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateProcessorDataId = updateProcessorDataId;
exports.getDefaultProcessor = getDefaultProcessor;
exports.execute_processor = execute_processor;
exports.execute_processor_tasks = execute_processor_tasks;
exports.batch_processing_task = batch_processing_task;
exports.add_dataset_columns = add_dataset_columns;
exports.update_dataset_column = update_dataset_column;
exports.PROCESSOR_UPDATER_PROPS = exports.PROCESS_TASK_FUNCS = exports.PROCESS_NEW_COLS = exports.PROCESS_MULTIDATA_FUNCS = exports.PROCESS_FUNCS = exports.PROCESSOR_ID_LENGTH = exports.DEFAULT_EXPORT_PROCESSOR_STRUCTURE = exports.DEFAULT_SPATIAL_PROCESSOR_STRUCTURE = exports.DEFAULT_TEMPORAL_PROCESSOR_STRUCTURE = exports.DEFAULT_GMT_PROCESSOR_STRUCTURE = exports.DEFAULT_PROCESSOR_STRUCTURE = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _keymirror = _interopRequireDefault(require("keymirror"));

var _utils = require("./utils");

var _defaultSettings = require("../constants/default-settings");

var _spatialProcessorUtils = require("./processor-utils/spatial-processor-utils");

var _googleapiProcessorUtils = require("./processor-utils/googleapi-processor-utils");

var _numericalProcessorUtils = require("./processor-utils/numerical-processor-utils");

var _generalProcessorUtils = require("./processor-utils/general-processor-utils");

var _datasetExtensionUtils = require("./dataset-extension-utils");

var _temporalProcessorUtils = require("./processor-utils/temporal-processor-utils");

var _lodash = _interopRequireDefault(require("lodash"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

//if processor will have output?
//id is not used in processor:
var DEFAULT_PROCESSOR_STRUCTURE = {
  dataId: [],
  // [string]
  // field specific
  name: null,
  // string
  type: null,
  fieldIdx: [],
  // [integer]
  domain: null,
  value: null,
  taskflag: false,
  attrs: {},
  join: {},
  batch: {
    oddataID: null,
    gpsdataID: null,
    poidataID: null,
    spatialFilter: null,
    temporalFilter: null,
    apikey: null,
    dbChecked: false,
    exportSetting: {
      outData: [],
      outColumns: ['datetime', 'gps', 'address', 'transportation mode', 'poi type'],
      header: true
    }
  }
};
exports.DEFAULT_PROCESSOR_STRUCTURE = DEFAULT_PROCESSOR_STRUCTURE;
var DEFAULT_GMT_PROCESSOR_STRUCTURE = {
  oddataID: null,
  gpsdataID: null,
  spatialFilter: null,
  temporalFilter: null,
  apikey: null //export filter: filtered origin data; merged poi data;

};
exports.DEFAULT_GMT_PROCESSOR_STRUCTURE = DEFAULT_GMT_PROCESSOR_STRUCTURE;
var DEFAULT_TEMPORAL_PROCESSOR_STRUCTURE = {
  dow: null,
  dateRange: [],
  removeHoliday: false,
  startTime: '07:00:00',
  endTime: '23:00:00',
  floor: 5
};
exports.DEFAULT_TEMPORAL_PROCESSOR_STRUCTURE = DEFAULT_TEMPORAL_PROCESSOR_STRUCTURE;
var DEFAULT_SPATIAL_PROCESSOR_STRUCTURE = {
  level: '大字・町',
  coordsModify: true,
  //if poiType true
  poiType: true,
  geometryFilter: null
};
exports.DEFAULT_SPATIAL_PROCESSOR_STRUCTURE = DEFAULT_SPATIAL_PROCESSOR_STRUCTURE;
var DEFAULT_EXPORT_PROCESSOR_STRUCTURE = {
  outData: ['OD data', 'GPS data', 'POI data'],
  outColumns: ['datetime', 'gps', 'address', 'transportation mode', 'poi type'],
  header: true
};
exports.DEFAULT_EXPORT_PROCESSOR_STRUCTURE = DEFAULT_EXPORT_PROCESSOR_STRUCTURE;
var PROCESSOR_ID_LENGTH = 4;
exports.PROCESSOR_ID_LENGTH = PROCESSOR_ID_LENGTH;

function updateProcessorDataId(dataId) {
  return getDefaultProcessor(dataId);
}

function getDefaultProcessor(dataId) {
  return _objectSpread(_objectSpread({}, DEFAULT_PROCESSOR_STRUCTURE), {}, {
    // store it as dataId and it could be one or many
    dataId: (0, _utils.toArray)(dataId),
    id: (0, _utils.generateHashId)(PROCESSOR_ID_LENGTH),
    field: null
  });
} // export function getProcessorFunction(method_name){
//
// }


var PROCESS_FUNCS = {
  //geoprocess
  CENTROID_EXTRACTION: _spatialProcessorUtils.centroid_extraction,
  MESHCODE_GENERALIZATION: _spatialProcessorUtils.meshcode_generalization,
  MESHCODE_AGGREGATION: _spatialProcessorUtils.meshcode_aggregation,
  MESHCODE_GENERATION: _spatialProcessorUtils.meshcode_generation,
  WKB_GENERATION: _spatialProcessorUtils.wkb_generation,
  //float process
  DIGIT_SLICING: _numericalProcessorUtils.digit_slicing,
  //filtering will generate new datasets or modify the original datasets;
  //time process:
  TIME_FLOORING: _temporalProcessorUtils.time_flooring //time indexing will change
  // TIME_INDEXING:time_indexing;

};
exports.PROCESS_FUNCS = PROCESS_FUNCS;
var PROCESS_MULTIDATA_FUNCS = {
  TABLE_JOIN: _datasetExtensionUtils.dataset_joining,
  SPATIAL_MASKING: _spatialProcessorUtils.spatial_masking,
  TIME_OD_JOIN: _datasetExtensionUtils.range_joining
};
exports.PROCESS_MULTIDATA_FUNCS = PROCESS_MULTIDATA_FUNCS;
var PROCESS_NEW_COLS = {
  CENTROID_EXTRACTION: 'centroid',
  MESHCODE_GENERALIZATION: 'meshcode',
  WKB_GENERATION: 'wkb',
  GOOGLE_API_QUERY: 'address',
  GEOCODING: ['lat', 'lng'],
  TYPE_CONVERSION: 'poi_type',
  REVERSE_GEOCODING: 'new_address'
}; //current state might be not enough? tbd

exports.PROCESS_NEW_COLS = PROCESS_NEW_COLS;
var PROCESS_TASK_FUNCS = {
  //google process:
  GOOGLE_API_QUERY: _googleapiProcessorUtils.server_place_id_query,
  GEOCODING: _googleapiProcessorUtils.geocoding_api_query,
  TYPE_CONVERSION: _googleapiProcessorUtils.server_poi_type_query
}; //dataset processor: here it is necessary to process the file:

exports.PROCESS_TASK_FUNCS = PROCESS_TASK_FUNCS;

function execute_processor(datasets, processor) {
  // return execute_processor()
  console.log('run execute processor');
  var method = processor.method,
      category = processor.category,
      dataId = processor.dataId,
      id = processor.id,
      name = processor.name,
      attrs = processor.attrs;
  attrs.col = name.id;

  if (name.type === 'geojson') {
    attrs.geom_col = name.id;
  }

  if (name.type === 'point') {
    // attrs.geom_col =
    attrs.col = name.pair;
    attrs.geom_col = name.pair;
  } //here is the functions that includes two datasets


  if (/[Mm]ask|[Jj]oin/.test(method)) {
    var PROCESS_ID = Object.keys(_defaultSettings.PROCESS_ITEMS).find(function (key) {
      return _defaultSettings.PROCESS_ITEMS[key] === method;
    });
    var new_datasets = (0, _generalProcessorUtils.datasets_interaction_process)(datasets, attrs, dataId, PROCESS_MULTIDATA_FUNCS[PROCESS_ID], 'merged');
    return {
      dataset: new_datasets,
      flag: 0
    };
  } else {
    var dataset = datasets[dataId[0]];

    if (dataset === undefined) {
      return {
        dataset: dataset,
        flag: -1
      };
    } else {
      try {
        var _PROCESS_ID = Object.keys(_defaultSettings.PROCESS_ITEMS).find(function (key) {
          return _defaultSettings.PROCESS_ITEMS[key] === method;
        });

        var process_func = PROCESS_FUNCS[_PROCESS_ID];

        if (process_func === undefined && PROCESS_TASK_FUNCS[_PROCESS_ID]) {
          return {
            dataset: dataset,
            flag: 2
          };
        }

        var new_dataset = process_func(dataset, attrs);
        return {
          dataset: new_dataset,
          flag: 1
        };
      } catch (e) {
        console.log(e);
        return {
          dataset: dataset,
          flag: -2
        };
      }
    }
  }
}

var PROCESSOR_UPDATER_PROPS = (0, _keymirror["default"])({
  dataId: null,
  name: null,
  layerId: null
});
exports.PROCESSOR_UPDATER_PROPS = PROCESSOR_UPDATER_PROPS;

function execute_processor_tasks(datasets, processor, visStateAction) {
  var method = processor.method,
      dataId = processor.dataId,
      attrs = processor.attrs;
  attrs.dataId = dataId[0];
  attrs.visStateAction = visStateAction;
  var dataset = datasets[dataId[0]];
  var PROCESS_ID = Object.keys(_defaultSettings.PROCESS_ITEMS).find(function (key) {
    return _defaultSettings.PROCESS_ITEMS[key] === method;
  });
  var process_func = PROCESS_TASK_FUNCS[PROCESS_ID];
  return process_func(dataset, attrs);
}

function batch_processing_task(datasets, batchAttrs, visStateAction) {
  var oddataID = batchAttrs.oddataID,
      gpsdataID = batchAttrs.gpsdataID,
      poidataID = batchAttrs.poidataID,
      spatialFilter = batchAttrs.spatialFilter,
      temporalFilter = batchAttrs.temporalFilter,
      apikey = batchAttrs.apikey,
      exportSetting = batchAttrs.exportSetting;
  var outData = exportSetting.outData,
      outColumns = exportSetting.outColumns,
      headers = exportSetting.headers;
  console.log('batch processing task');

  var new_datasets = _lodash["default"].cloneDeep(datasets);

  if (temporalFilter) {
    if (oddataID) {
      var _DATASET_COLUMNS$odda = _defaultSettings.DATASET_COLUMNS.oddata,
          datetime = _DATASET_COLUMNS$odda.datetime,
          date = _DATASET_COLUMNS$odda.date;
      new_datasets[oddataID] = (0, _datasetExtensionUtils.reset_index_dataset)((0, _temporalProcessorUtils.batch_temporal_filter_process)(new_datasets[oddataID], datetime[0], date[0], temporalFilter)); // delete new_datasets[oddataID]
    }

    if (gpsdataID) {
      var _datetime = _defaultSettings.DATASET_COLUMNS.gpsdata.datetime;
      new_datasets[gpsdataID] = (0, _datasetExtensionUtils.reset_index_dataset)((0, _temporalProcessorUtils.batch_temporal_filter_process)(new_datasets[gpsdataID], _datetime, _datetime, temporalFilter)); // delete new_datasets[gpsdataID]
    }

    if (poidataID) {
      var _DATASET_COLUMNS$poid = _defaultSettings.DATASET_COLUMNS.poidata,
          _datetime2 = _DATASET_COLUMNS$poid.datetime,
          _date = _DATASET_COLUMNS$poid.date;
      new_datasets[poidataID] = (0, _datasetExtensionUtils.reset_index_dataset)((0, _temporalProcessorUtils.batch_temporal_filter_process)(new_datasets[poidataID], _datetime2[0], _date[0], temporalFilter)); // delete new_datasets[poidataID]
    }
  } //here conduct temporal interaction


  console.log('here conduct temporal interaction');

  if (oddataID && gpsdataID && outData.filter(function (x) {
    return /GPS/.test(x);
  }).length > 0) {
    if (temporalFilter) {
      new_datasets[gpsdataID] = (0, _datasetExtensionUtils.reset_index_dataset)((0, _datasetExtensionUtils.range_joining)(new_datasets[gpsdataID], new_datasets[oddataID], null, false, _defaultSettings.DATASET_COLUMNS['gpsdata'].datetime[0], _defaultSettings.DATASET_COLUMNS['oddata'].datetime[0], false));
    }
  } //here conduct spatial filtering, issue: spatialFiltering requires async, how to merge here?


  if (spatialFilter) {
    console.log('spatial Filter generation');
    var level = spatialFilter.level,
        coordsModify = spatialFilter.coordsModify,
        geometryFilter = spatialFilter.geometryFilter;

    if (geometryFilter) {
      new_datasets = (0, _spatialProcessorUtils.batch_spatial_geometry_filter)(new_datasets, geometryFilter, oddataID, gpsdataID, poidataID);
    }

    console.log(level);

    if (level && outData.filter(function (x) {
      return /{activity|visited}/.test(x);
    })) {
      var total_cols = [];

      if (oddataID) {
        total_cols = total_cols.concat((0, _datasetExtensionUtils.distinct_value_lists)(new_datasets[oddataID], _defaultSettings.DATASET_COLUMNS['oddata']['id']));
      }

      if (poidataID) {
        total_cols = total_cols.concat((0, _datasetExtensionUtils.distinct_value_lists)(new_datasets[oddataID], _defaultSettings.DATASET_COLUMNS['oddata']['id']));
      }

      var query_id_list = _lodash["default"].uniq(total_cols);

      var paras = {
        atype: coordsModify ? 'batchmod' : 'batchgen',
        engine: 'google',
        lang: 'ja',
        token: apikey,
        precision: _defaultSettings.ADDRESS_LEVEL_DICT[level]
      };
      var api_template = 'http://localhost:8000/api/queryid?';

      if (query_id_list.length === 0) {
        return {
          result: new_datasets,
          flag: 1
        };
      }

      console.log('api query list task here'); //here to determine future process issues

      return {
        result: (0, _googleapiProcessorUtils.getAPIQueryListTasks)(query_id_list.map(function (x) {
          var url = api_template + new URLSearchParams(_objectSpread(_objectSpread({}, paras), {
            place_id: x
          })).toString();
          return url;
        }), visStateAction, new_datasets),
        flag: 2
      };
    }
  } //todo: how to make the file downloadable?
  // return exportFilteringProcess(datasets,exportSetting)


  return {
    result: new_datasets,
    flag: 1
  };
}

function add_dataset_columns(dataset, columns, data_types, values, if_exists) {}

function update_dataset_column(dataset, column, values) {}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9wcm9jZXNzb3ItdXRpbHMuanMiXSwibmFtZXMiOlsiREVGQVVMVF9QUk9DRVNTT1JfU1RSVUNUVVJFIiwiZGF0YUlkIiwibmFtZSIsInR5cGUiLCJmaWVsZElkeCIsImRvbWFpbiIsInZhbHVlIiwidGFza2ZsYWciLCJhdHRycyIsImpvaW4iLCJiYXRjaCIsIm9kZGF0YUlEIiwiZ3BzZGF0YUlEIiwicG9pZGF0YUlEIiwic3BhdGlhbEZpbHRlciIsInRlbXBvcmFsRmlsdGVyIiwiYXBpa2V5IiwiZGJDaGVja2VkIiwiZXhwb3J0U2V0dGluZyIsIm91dERhdGEiLCJvdXRDb2x1bW5zIiwiaGVhZGVyIiwiREVGQVVMVF9HTVRfUFJPQ0VTU09SX1NUUlVDVFVSRSIsIkRFRkFVTFRfVEVNUE9SQUxfUFJPQ0VTU09SX1NUUlVDVFVSRSIsImRvdyIsImRhdGVSYW5nZSIsInJlbW92ZUhvbGlkYXkiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiZmxvb3IiLCJERUZBVUxUX1NQQVRJQUxfUFJPQ0VTU09SX1NUUlVDVFVSRSIsImxldmVsIiwiY29vcmRzTW9kaWZ5IiwicG9pVHlwZSIsImdlb21ldHJ5RmlsdGVyIiwiREVGQVVMVF9FWFBPUlRfUFJPQ0VTU09SX1NUUlVDVFVSRSIsIlBST0NFU1NPUl9JRF9MRU5HVEgiLCJ1cGRhdGVQcm9jZXNzb3JEYXRhSWQiLCJnZXREZWZhdWx0UHJvY2Vzc29yIiwiaWQiLCJmaWVsZCIsIlBST0NFU1NfRlVOQ1MiLCJDRU5UUk9JRF9FWFRSQUNUSU9OIiwiY2VudHJvaWRfZXh0cmFjdGlvbiIsIk1FU0hDT0RFX0dFTkVSQUxJWkFUSU9OIiwibWVzaGNvZGVfZ2VuZXJhbGl6YXRpb24iLCJNRVNIQ09ERV9BR0dSRUdBVElPTiIsIm1lc2hjb2RlX2FnZ3JlZ2F0aW9uIiwiTUVTSENPREVfR0VORVJBVElPTiIsIm1lc2hjb2RlX2dlbmVyYXRpb24iLCJXS0JfR0VORVJBVElPTiIsIndrYl9nZW5lcmF0aW9uIiwiRElHSVRfU0xJQ0lORyIsImRpZ2l0X3NsaWNpbmciLCJUSU1FX0ZMT09SSU5HIiwidGltZV9mbG9vcmluZyIsIlBST0NFU1NfTVVMVElEQVRBX0ZVTkNTIiwiVEFCTEVfSk9JTiIsImRhdGFzZXRfam9pbmluZyIsIlNQQVRJQUxfTUFTS0lORyIsInNwYXRpYWxfbWFza2luZyIsIlRJTUVfT0RfSk9JTiIsInJhbmdlX2pvaW5pbmciLCJQUk9DRVNTX05FV19DT0xTIiwiR09PR0xFX0FQSV9RVUVSWSIsIkdFT0NPRElORyIsIlRZUEVfQ09OVkVSU0lPTiIsIlJFVkVSU0VfR0VPQ09ESU5HIiwiUFJPQ0VTU19UQVNLX0ZVTkNTIiwic2VydmVyX3BsYWNlX2lkX3F1ZXJ5IiwiZ2VvY29kaW5nX2FwaV9xdWVyeSIsInNlcnZlcl9wb2lfdHlwZV9xdWVyeSIsImV4ZWN1dGVfcHJvY2Vzc29yIiwiZGF0YXNldHMiLCJwcm9jZXNzb3IiLCJjb25zb2xlIiwibG9nIiwibWV0aG9kIiwiY2F0ZWdvcnkiLCJjb2wiLCJnZW9tX2NvbCIsInBhaXIiLCJ0ZXN0IiwiUFJPQ0VTU19JRCIsIk9iamVjdCIsImtleXMiLCJQUk9DRVNTX0lURU1TIiwiZmluZCIsImtleSIsIm5ld19kYXRhc2V0cyIsImRhdGFzZXQiLCJmbGFnIiwidW5kZWZpbmVkIiwicHJvY2Vzc19mdW5jIiwibmV3X2RhdGFzZXQiLCJlIiwiUFJPQ0VTU09SX1VQREFURVJfUFJPUFMiLCJsYXllcklkIiwiZXhlY3V0ZV9wcm9jZXNzb3JfdGFza3MiLCJ2aXNTdGF0ZUFjdGlvbiIsImJhdGNoX3Byb2Nlc3NpbmdfdGFzayIsImJhdGNoQXR0cnMiLCJoZWFkZXJzIiwiXyIsImNsb25lRGVlcCIsIkRBVEFTRVRfQ09MVU1OUyIsIm9kZGF0YSIsImRhdGV0aW1lIiwiZGF0ZSIsImdwc2RhdGEiLCJwb2lkYXRhIiwiZmlsdGVyIiwieCIsImxlbmd0aCIsInRvdGFsX2NvbHMiLCJjb25jYXQiLCJxdWVyeV9pZF9saXN0IiwidW5pcSIsInBhcmFzIiwiYXR5cGUiLCJlbmdpbmUiLCJsYW5nIiwidG9rZW4iLCJwcmVjaXNpb24iLCJBRERSRVNTX0xFVkVMX0RJQ1QiLCJhcGlfdGVtcGxhdGUiLCJyZXN1bHQiLCJtYXAiLCJ1cmwiLCJVUkxTZWFyY2hQYXJhbXMiLCJwbGFjZV9pZCIsInRvU3RyaW5nIiwiYWRkX2RhdGFzZXRfY29sdW1ucyIsImNvbHVtbnMiLCJkYXRhX3R5cGVzIiwidmFsdWVzIiwiaWZfZXhpc3RzIiwidXBkYXRlX2RhdGFzZXRfY29sdW1uIiwiY29sdW1uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBUUE7O0FBS0E7O0FBQ0E7O0FBQ0E7O0FBT0E7O0FBQ0E7Ozs7OztBQUVBO0FBRUE7QUFDTyxJQUFNQSwyQkFBMkIsR0FBRztBQUN6Q0MsRUFBQUEsTUFBTSxFQUFFLEVBRGlDO0FBQzdCO0FBQ1o7QUFDQUMsRUFBQUEsSUFBSSxFQUFFLElBSG1DO0FBRzdCO0FBQ1pDLEVBQUFBLElBQUksRUFBRSxJQUptQztBQUt6Q0MsRUFBQUEsUUFBUSxFQUFFLEVBTCtCO0FBSzNCO0FBQ2RDLEVBQUFBLE1BQU0sRUFBRSxJQU5pQztBQU96Q0MsRUFBQUEsS0FBSyxFQUFFLElBUGtDO0FBUXpDQyxFQUFBQSxRQUFRLEVBQUMsS0FSZ0M7QUFTekNDLEVBQUFBLEtBQUssRUFBQyxFQVRtQztBQVV6Q0MsRUFBQUEsSUFBSSxFQUFDLEVBVm9DO0FBV3pDQyxFQUFBQSxLQUFLLEVBQUM7QUFDSkMsSUFBQUEsUUFBUSxFQUFDLElBREw7QUFFSkMsSUFBQUEsU0FBUyxFQUFDLElBRk47QUFHSkMsSUFBQUEsU0FBUyxFQUFDLElBSE47QUFJSkMsSUFBQUEsYUFBYSxFQUFDLElBSlY7QUFLSkMsSUFBQUEsY0FBYyxFQUFDLElBTFg7QUFNSkMsSUFBQUEsTUFBTSxFQUFDLElBTkg7QUFPSkMsSUFBQUEsU0FBUyxFQUFDLEtBUE47QUFRSkMsSUFBQUEsYUFBYSxFQUFDO0FBQ1pDLE1BQUFBLE9BQU8sRUFB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RUFHR1YsWUFISCxDQUFSO0FBR3lCRSxRQUFBQSxJQUFJLEVBQUM7QUFIOUIsT0FBUDtBQUtEO0FBRUYsR0FwRnNFLENBc0Z2RTtBQUNBOzs7QUFDQSxTQUFPO0FBQUNtQyxJQUFBQSxNQUFNLEVBQUNyQyxZQUFSO0FBQXFCRSxJQUFBQSxJQUFJLEVBQUM7QUFBMUIsR0FBUDtBQUVEOztBQUdNLFNBQVN5QyxtQkFBVCxDQUE2QjFDLE9BQTdCLEVBQXFDMkMsT0FBckMsRUFBNkNDLFVBQTdDLEVBQXdEQyxNQUF4RCxFQUErREMsU0FBL0QsRUFBeUUsQ0FFL0U7O0FBSU0sU0FBU0MscUJBQVQsQ0FBK0IvQyxPQUEvQixFQUF1Q2dELE1BQXZDLEVBQThDSCxNQUE5QyxFQUFxRCxDQUczRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAyMiBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBrZXlNaXJyb3IgZnJvbSAna2V5bWlycm9yJztcbmltcG9ydCB7Z2VuZXJhdGVIYXNoSWQsIHNldCwgdG9BcnJheX0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQge0FERFJFU1NfTEVWRUxfRElDVCwgREFUQVNFVF9DT0xVTU5TLCBQUk9DRVNTX0lURU1TfSBmcm9tICcuLi9jb25zdGFudHMvZGVmYXVsdC1zZXR0aW5ncyc7XG5pbXBvcnQge1xuICBiYXRjaF9zcGF0aWFsX2dlb21ldHJ5X2ZpbHRlcixcbiAgY2VudHJvaWRfZXh0cmFjdGlvbixcbiAgbWVzaGNvZGVfYWdncmVnYXRpb24sXG4gIG1lc2hjb2RlX2dlbmVyYWxpemF0aW9uLFxuICBtZXNoY29kZV9nZW5lcmF0aW9uLCBzcGF0aWFsX21hc2tpbmcsXG4gIHdrYl9nZW5lcmF0aW9uXG59IGZyb20gJy4vcHJvY2Vzc29yLXV0aWxzL3NwYXRpYWwtcHJvY2Vzc29yLXV0aWxzJztcbmltcG9ydCB7XG4gIGdlb2NvZGluZ19hcGlfcXVlcnksIGdldEFQSVF1ZXJ5TGlzdFRhc2tzLFxuICBzZXJ2ZXJfcGxhY2VfaWRfcXVlcnksXG4gIHNlcnZlcl9wb2lfdHlwZV9xdWVyeVxufSBmcm9tICcuL3Byb2Nlc3Nvci11dGlscy9nb29nbGVhcGktcHJvY2Vzc29yLXV0aWxzJztcbmltcG9ydCB7ZGlnaXRfc2xpY2luZ30gZnJvbSAnLi9wcm9jZXNzb3ItdXRpbHMvbnVtZXJpY2FsLXByb2Nlc3Nvci11dGlscyc7XG5pbXBvcnQge2RhdGFzZXRzX2ludGVyYWN0aW9uX3Byb2Nlc3N9IGZyb20gJy4vcHJvY2Vzc29yLXV0aWxzL2dlbmVyYWwtcHJvY2Vzc29yLXV0aWxzJztcbmltcG9ydCB7XG4gIGRhdGFzZXRfam9pbmluZyxcbiAgZGlzdGluY3RfdmFsdWVfbGlzdHMsXG4gIGV4cG9ydEZpbHRlcmluZ1Byb2Nlc3MsXG4gIHJhbmdlX2pvaW5pbmcsXG4gIHJlc2V0X2luZGV4X2RhdGFzZXRcbn0gZnJvbSAnLi9kYXRhc2V0LWV4dGVuc2lvbi11dGlscyc7XG5pbXBvcnQge2JhdGNoX3RlbXBvcmFsX2ZpbHRlcl9wcm9jZXNzLCB0aW1lX2Zsb29yaW5nfSBmcm9tICcuL3Byb2Nlc3Nvci11dGlscy90ZW1wb3JhbC1wcm9jZXNzb3ItdXRpbHMnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcblxuLy9pZiBwcm9jZXNzb3Igd2lsbCBoYXZlIG91dHB1dD9cblxuLy9pZCBpcyBub3QgdXNlZCBpbiBwcm9jZXNzb3I6XG5leHBvcnQgY29uc3QgREVGQVVMVF9QUk9DRVNTT1JfU1RSVUNUVVJFID0ge1xuICBkYXRhSWQ6IFtdLCAvLyBbc3RyaW5nXVxuICAvLyBmaWVsZCBzcGVjaWZpY1xuICBuYW1lOiBudWxsLCAvLyBzdHJpbmdcbiAgdHlwZTogbnVsbCxcbiAgZmllbGRJZHg6IFtdLCAvLyBbaW50ZWdlcl1cbiAgZG9tYWluOiBudWxsLFxuICB2YWx1ZTogbnVsbCxcbiAgdGFza2ZsYWc6ZmFsc2UsXG4gIGF0dHJzOnt9LFxuICBqb2luOnt9LFxuICBiYXRjaDp7XG4gICAgb2RkYXRhSUQ6bnVsbCxcbiAgICBncHNkYXRhSUQ6bnVsbCxcbiAgICBwb2lkYXRhSUQ6bnVsbCxcbiAgICBzcGF0aWFsRmlsdGVyOm51bGwsXG4gICAgdGVtcG9yYWxGaWx0ZXI6bnVsbCxcbiAgICBhcGlrZXk6bnVsbCxcbiAgICBkYkNoZWNrZWQ6ZmFsc2UsXG4gICAgZXhwb3J0U2V0dGluZzp7XG4gICAgICBvdXREYXRhOltdLFxuICAgICAgb3V0Q29sdW1uczpbJ2RhdGV0aW1lJywgJ2dwcycsICdhZGRyZXNzJywgJ3RyYW5zcG9ydGF0aW9uIG1vZGUnLCAncG9pIHR5cGUnXSxcbiAgICAgIGhlYWRlcjp0cnVlLFxuICAgIH0sXG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0dNVF9QUk9DRVNTT1JfU1RSVUNUVVJFID0ge1xuXG4gIG9kZGF0YUlEOm51bGwsXG4gIGdwc2RhdGFJRDpudWxsLFxuXG4gIHNwYXRpYWxGaWx0ZXI6bnVsbCxcbiAgdGVtcG9yYWxGaWx0ZXI6bnVsbCxcblxuICBhcGlrZXk6bnVsbCxcblxuICAvL2V4cG9ydCBmaWx0ZXI6IGZpbHRlcmVkIG9yaWdpbiBkYXRhOyBtZXJnZWQgcG9pIGRhdGE7XG5cbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVEVNUE9SQUxfUFJPQ0VTU09SX1NUUlVDVFVSRSA9IHtcbiAgZG93Om51bGwsXG4gIGRhdGVSYW5nZTpbXSxcbiAgcmVtb3ZlSG9saWRheTpmYWxzZSxcbiAgc3RhcnRUaW1lOicwNzowMDowMCcsXG4gIGVuZFRpbWU6JzIzOjAwOjAwJyxcbiAgZmxvb3I6NSxcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU1BBVElBTF9QUk9DRVNTT1JfU1RSVUNUVVJFID0ge1xuICBsZXZlbDon5aSn5a2X44O755S6JyxcbiAgY29vcmRzTW9kaWZ5OnRydWUsXG4gIC8vaWYgcG9pVHlwZSB0cnVlXG4gIHBvaVR5cGU6dHJ1ZSxcbiAgZ2VvbWV0cnlGaWx0ZXI6bnVsbFxufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9FWFBPUlRfUFJPQ0VTU09SX1NUUlVDVFVSRSA9IHtcbiAgb3V0RGF0YTpbJ09EIGRhdGEnLCdHUFMgZGF0YScsJ1BPSSBkYXRhJ10sXG4gIG91dENvbHVtbnM6WydkYXRldGltZScsICdncHMnLCAnYWRkcmVzcycsICd0cmFuc3BvcnRhdGlvbiBtb2RlJywgJ3BvaSB0eXBlJ10sXG4gIGhlYWRlcjp0cnVlXG59XG5cblxuXG5leHBvcnQgY29uc3QgUFJPQ0VTU09SX0lEX0xFTkdUSCA9IDQ7XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVQcm9jZXNzb3JEYXRhSWQoZGF0YUlkKSB7XG4gIHJldHVybiBnZXREZWZhdWx0UHJvY2Vzc29yKGRhdGFJZCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0UHJvY2Vzc29yKGRhdGFJZCkge1xuICByZXR1cm4ge1xuICAgIC4uLkRFRkFVTFRfUFJPQ0VTU09SX1NUUlVDVFVSRSxcbiAgICAvLyBzdG9yZSBpdCBhcyBkYXRhSWQgYW5kIGl0IGNvdWxkIGJlIG9uZSBvciBtYW55XG4gICAgZGF0YUlkOiB0b0FycmF5KGRhdGFJZCksXG4gICAgaWQ6IGdlbmVyYXRlSGFzaElkKFBST0NFU1NPUl9JRF9MRU5HVEgpLFxuICAgIGZpZWxkOm51bGwsXG4gIH07XG59XG5cbi8vIGV4cG9ydCBmdW5jdGlvbiBnZXRQcm9jZXNzb3JGdW5jdGlvbihtZXRob2RfbmFtZSl7XG4vL1xuLy8gfVxuXG5leHBvcnQgY29uc3QgUFJPQ0VTU19GVU5DUyA9XG4gIHtcbiAgICAvL2dlb3Byb2Nlc3NcbiAgICBDRU5UUk9JRF9FWFRSQUNUSU9OOiBjZW50cm9pZF9leHRyYWN0aW9uLFxuICAgIE1FU0hDT0RFX0dFTkVSQUxJWkFUSU9OOiBtZXNoY29kZV9nZW5lcmFsaXphdGlvbixcbiAgICBNRVNIQ09ERV9BR0dSRUdBVElPTjptZXNoY29kZV9hZ2dyZWdhdGlvbixcbiAgICBNRVNIQ09ERV9HRU5FUkFUSU9OOm1lc2hjb2RlX2dlbmVyYXRpb24sXG4gICAgV0tCX0dFTkVSQVRJT046d2tiX2dlbmVyYXRpb24sXG5cbiAgICAvL2Zsb2F0IHByb2Nlc3NcbiAgICBESUdJVF9TTElDSU5HOmRpZ2l0X3NsaWNpbmcsXG5cbiAgICAvL2ZpbHRlcmluZyB3aWxsIGdlbmVyYXRlIG5ldyBkYXRhc2V0cyBvciBtb2RpZnkgdGhlIG9yaWdpbmFsIGRhdGFzZXRzO1xuICAgIC8vdGltZSBwcm9jZXNzOlxuICAgIFRJTUVfRkxPT1JJTkc6dGltZV9mbG9vcmluZyxcbiAgICAvL3RpbWUgaW5kZXhpbmcgd2lsbCBjaGFuZ2VcbiAgICAvLyBUSU1FX0lOREVYSU5HOnRpbWVfaW5kZXhpbmc7XG5cbiAgfTtcblxuZXhwb3J0IGNvbnN0IFBST0NFU1NfTVVMVElEQVRBX0ZVTkNTID0ge1xuICBUQUJMRV9KT0lOOmRhdGFzZXRfam9pbmluZyxcbiAgU1BBVElBTF9NQVNLSU5HOnNwYXRpYWxfbWFza2luZyxcbiAgVElNRV9PRF9KT0lOOnJhbmdlX2pvaW5pbmcsXG59XG5cbmV4cG9ydCBjb25zdCBQUk9DRVNTX05FV19DT0xTID0ge1xuICBDRU5UUk9JRF9FWFRSQUNUSU9OOiAnY2VudHJvaWQnLFxuICBNRVNIQ09ERV9HRU5FUkFMSVpBVElPTjonbWVzaGNvZGUnLFxuICBXS0JfR0VORVJBVElPTjond2tiJyxcbiAgR09PR0xFX0FQSV9RVUVSWTonYWRkcmVzcycsXG4gIEdFT0NPRElORzpbJ2xhdCcsJ2xuZyddLFxuICBUWVBFX0NPTlZFUlNJT046J3BvaV90eXBlJyxcbiAgUkVWRVJTRV9HRU9DT0RJTkc6ICduZXdfYWRkcmVzcycsXG59XG5cbi8vY3VycmVudCBzdGF0ZSBtaWdodCBiZSBub3QgZW5vdWdoPyB0YmRcbmV4cG9ydCBjb25zdCBQUk9DRVNTX1RBU0tfRlVOQ1MgPSAge1xuICAvL2dvb2dsZSBwcm9jZXNzOlxuICBHT09HTEVfQVBJX1FVRVJZOiBzZXJ2ZXJfcGxhY2VfaWRfcXVlcnksXG4gIEdFT0NPRElORzogZ2VvY29kaW5nX2FwaV9xdWVyeSxcbiAgVFlQRV9DT05WRVJTSU9OOnNlcnZlcl9wb2lfdHlwZV9xdWVyeSxcbn1cblxuLy9kYXRhc2V0IHByb2Nlc3NvcjogaGVyZSBpdCBpcyBuZWNlc3NhcnkgdG8gcHJvY2VzcyB0aGUgZmlsZTpcbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlX3Byb2Nlc3NvcihkYXRhc2V0cyxwcm9jZXNzb3Ipe1xuICAvLyByZXR1cm4gZXhlY3V0ZV9wcm9jZXNzb3IoKVxuICBjb25zb2xlLmxvZygncnVuIGV4ZWN1dGUgcHJvY2Vzc29yJylcbiAgY29uc3Qge21ldGhvZCxjYXRlZ29yeSxkYXRhSWQsaWQsbmFtZSxhdHRyc30gPSBwcm9jZXNzb3JcblxuICBhdHRycy5jb2wgPSBuYW1lLmlkXG5cbiAgaWYobmFtZS50eXBlID09PSAnZ2VvanNvbicpe1xuICAgIGF0dHJzLmdlb21fY29sICA9IG5hbWUuaWRcbiAgfVxuXG4gIGlmKG5hbWUudHlwZSA9PT0gJ3BvaW50Jyl7XG4gICAgLy8gYXR0cnMuZ2VvbV9jb2wgPVxuICAgIGF0dHJzLmNvbCA9IG5hbWUucGFpclxuICAgIGF0dHJzLmdlb21fY29sID0gbmFtZS5wYWlyXG4gIH1cblxuICAvL2hlcmUgaXMgdGhlIGZ1bmN0aW9ucyB0aGF0IGluY2x1ZGVzIHR3byBkYXRhc2V0c1xuICBpZigvW01tXWFza3xbSmpdb2luLy50ZXN0KG1ldGhvZCkpe1xuICAgIGNvbnN0IFBST0NFU1NfSUQgPSBPYmplY3Qua2V5cyhQUk9DRVNTX0lURU1TKS5maW5kKGtleSA9PiBQUk9DRVNTX0lURU1TW2tleV0gPT09IG1ldGhvZClcbiAgICBjb25zdCBuZXdfZGF0YXNldHMgPSBkYXRhc2V0c19pbnRlcmFjdGlvbl9wcm9jZXNzKGRhdGFzZXRzLGF0dHJzLGRhdGFJZCxQUk9DRVNTX01VTFRJREFUQV9GVU5DU1tQUk9DRVNTX0lEXSwnbWVyZ2VkJylcbiAgICByZXR1cm4ge2RhdGFzZXQ6bmV3X2RhdGFzZXRzLGZsYWc6MH1cbiAgfVxuICBlbHNle1xuICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tkYXRhSWRbMF1dXG4gICAgaWYoZGF0YXNldCA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiB7ZGF0YXNldDpkYXRhc2V0LGZsYWc6LTF9XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBQUk9DRVNTX0lEID0gT2JqZWN0LmtleXMoUFJPQ0VTU19JVEVNUykuZmluZChrZXkgPT4gUFJPQ0VTU19JVEVNU1trZXldID09PSBtZXRob2QpXG4gICAgICAgIGNvbnN0IHByb2Nlc3NfZnVuYyA9IFBST0NFU1NfRlVOQ1NbUFJPQ0VTU19JRF1cbiAgICAgICAgaWYocHJvY2Vzc19mdW5jID09PSB1bmRlZmluZWQgJiYgUFJPQ0VTU19UQVNLX0ZVTkNTW1BST0NFU1NfSURdKXtcbiAgICAgICAgICByZXR1cm4ge2RhdGFzZXQ6ZGF0YXNldCxmbGFnOjJ9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3X2RhdGFzZXQgPSBwcm9jZXNzX2Z1bmMoZGF0YXNldCxhdHRycylcbiAgICAgICAgcmV0dXJuIHtkYXRhc2V0Om5ld19kYXRhc2V0LGZsYWc6MX1cbiAgICAgIH1cbiAgICAgIGNhdGNoKGUpe1xuICAgICAgICBjb25zb2xlLmxvZyhlKVxuICAgICAgICByZXR1cm4ge2RhdGFzZXQ6ZGF0YXNldCxmbGFnOi0yfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCBjb25zdCBQUk9DRVNTT1JfVVBEQVRFUl9QUk9QUyA9IGtleU1pcnJvcih7XG4gIGRhdGFJZDogbnVsbCxcbiAgbmFtZTogbnVsbCxcbiAgbGF5ZXJJZDogbnVsbFxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlX3Byb2Nlc3Nvcl90YXNrcyhkYXRhc2V0cyxwcm9jZXNzb3IsdmlzU3RhdGVBY3Rpb24pe1xuICBjb25zdCB7bWV0aG9kLGRhdGFJZCxhdHRyc30gPSBwcm9jZXNzb3JcbiAgYXR0cnMuZGF0YUlkID0gZGF0YUlkWzBdXG4gIGF0dHJzLnZpc1N0YXRlQWN0aW9uID0gdmlzU3RhdGVBY3Rpb25cbiAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzW2RhdGFJZFswXV1cbiAgY29uc3QgUFJPQ0VTU19JRCA9IE9iamVjdC5rZXlzKFBST0NFU1NfSVRFTVMpLmZpbmQoa2V5ID0+IFBST0NFU1NfSVRFTVNba2V5XSA9PT0gbWV0aG9kKVxuICBjb25zdCBwcm9jZXNzX2Z1bmMgPSBQUk9DRVNTX1RBU0tfRlVOQ1NbUFJPQ0VTU19JRF1cbiAgcmV0dXJuIHByb2Nlc3NfZnVuYyhkYXRhc2V0LGF0dHJzKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmF0Y2hfcHJvY2Vzc2luZ190YXNrKGRhdGFzZXRzLGJhdGNoQXR0cnMsdmlzU3RhdGVBY3Rpb24pe1xuICBjb25zdCB7b2RkYXRhSUQsIGdwc2RhdGFJRCwgcG9pZGF0YUlELCBzcGF0aWFsRmlsdGVyLCB0ZW1wb3JhbEZpbHRlciwgYXBpa2V5LGV4cG9ydFNldHRpbmd9ID0gYmF0Y2hBdHRyc1xuXG4gIGNvbnN0IHtvdXREYXRhLG91dENvbHVtbnMsaGVhZGVyc30gPSBleHBvcnRTZXR0aW5nXG5cbiAgY29uc29sZS5sb2coJ2JhdGNoIHByb2Nlc3NpbmcgdGFzaycpXG5cbiAgbGV0IG5ld19kYXRhc2V0cyA9IF8uY2xvbmVEZWVwKGRhdGFzZXRzKVxuXG4gIGlmKHRlbXBvcmFsRmlsdGVyKXtcbiAgICBpZihvZGRhdGFJRCl7XG4gICAgICBjb25zdCB7ZGF0ZXRpbWUsZGF0ZX0gPSBEQVRBU0VUX0NPTFVNTlMub2RkYXRhXG4gICAgICBuZXdfZGF0YXNldHNbb2RkYXRhSURdID0gcmVzZXRfaW5kZXhfZGF0YXNldChiYXRjaF90ZW1wb3JhbF9maWx0ZXJfcHJvY2VzcyhuZXdfZGF0YXNldHNbb2RkYXRhSURdLGRhdGV0aW1lWzBdLGRhdGVbMF0sdGVtcG9yYWxGaWx0ZXIpKVxuICAgICAgLy8gZGVsZXRlIG5ld19kYXRhc2V0c1tvZGRhdGFJRF1cbiAgICB9XG5cbiAgICBpZihncHNkYXRhSUQpe1xuICAgICAgY29uc3Qge2RhdGV0aW1lfSA9IERBVEFTRVRfQ09MVU1OUy5ncHNkYXRhXG4gICAgICBuZXdfZGF0YXNldHNbZ3BzZGF0YUlEXSA9IHJlc2V0X2luZGV4X2RhdGFzZXQoYmF0Y2hfdGVtcG9yYWxfZmlsdGVyX3Byb2Nlc3MobmV3X2RhdGFzZXRzW2dwc2RhdGFJRF0sZGF0ZXRpbWUsZGF0ZXRpbWUsdGVtcG9yYWxGaWx0ZXIpKVxuICAgICAgLy8gZGVsZXRlIG5ld19kYXRhc2V0c1tncHNkYXRhSURdXG4gICAgfVxuXG4gICAgaWYocG9pZGF0YUlEKXtcbiAgICAgIGNvbnN0IHtkYXRldGltZSxkYXRlfSA9IERBVEFTRVRfQ09MVU1OUy5wb2lkYXRhXG4gICAgICBuZXdfZGF0YXNldHNbcG9pZGF0YUlEXSA9IHJlc2V0X2luZGV4X2RhdGFzZXQoYmF0Y2hfdGVtcG9yYWxfZmlsdGVyX3Byb2Nlc3MobmV3X2RhdGFzZXRzW3BvaWRhdGFJRF0sZGF0ZXRpbWVbMF0sZGF0ZVswXSx0ZW1wb3JhbEZpbHRlcikpXG4gICAgICAvLyBkZWxldGUgbmV3X2RhdGFzZXRzW3BvaWRhdGFJRF1cbiAgICB9XG4gIH1cblxuICAvL2hlcmUgY29uZHVjdCB0ZW1wb3JhbCBpbnRlcmFjdGlvblxuICBjb25zb2xlLmxvZygnaGVyZSBjb25kdWN0IHRlbXBvcmFsIGludGVyYWN0aW9uJylcbiAgaWYob2RkYXRhSUQgJiYgZ3BzZGF0YUlEICYmIG91dERhdGEuZmlsdGVyKCh4KT0+L0dQUy8udGVzdCh4KSkubGVuZ3RoPjApe1xuICAgIGlmKHRlbXBvcmFsRmlsdGVyKXtcbiAgICAgIG5ld19kYXRhc2V0c1tncHNkYXRhSURdID0gcmVzZXRfaW5kZXhfZGF0YXNldChyYW5nZV9qb2luaW5nKG5ld19kYXRhc2V0c1tncHNkYXRhSURdLG5ld19kYXRhc2V0c1tvZGRhdGFJRF0sbnVsbCxmYWxzZSxEQVRBU0VUX0NPTFVNTlNbJ2dwc2RhdGEnXS5kYXRldGltZVswXSxEQVRBU0VUX0NPTFVNTlNbJ29kZGF0YSddLmRhdGV0aW1lWzBdLGZhbHNlKSlcbiAgICB9XG5cbiAgfVxuXG4gIC8vaGVyZSBjb25kdWN0IHNwYXRpYWwgZmlsdGVyaW5nLCBpc3N1ZTogc3BhdGlhbEZpbHRlcmluZyByZXF1aXJlcyBhc3luYywgaG93IHRvIG1lcmdlIGhlcmU/XG4gIGlmKHNwYXRpYWxGaWx0ZXIpe1xuICAgIGNvbnNvbGUubG9nKCdzcGF0aWFsIEZpbHRlciBnZW5lcmF0aW9uJylcbiAgICBjb25zdCB7bGV2ZWwsY29vcmRzTW9kaWZ5LGdlb21ldHJ5RmlsdGVyfSA9IHNwYXRpYWxGaWx0ZXJcbiAgICBpZihnZW9tZXRyeUZpbHRlcil7XG4gICAgICBuZXdfZGF0YXNldHMgPSBiYXRjaF9zcGF0aWFsX2dlb21ldHJ5X2ZpbHRlcihuZXdfZGF0YXNldHMsZ2VvbWV0cnlGaWx0ZXIsb2RkYXRhSUQsZ3BzZGF0YUlELHBvaWRhdGFJRClcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhsZXZlbClcblxuICAgIGlmKGxldmVsICYmIG91dERhdGEuZmlsdGVyKCh4KT0+L3thY3Rpdml0eXx2aXNpdGVkfS8udGVzdCh4KSkpe1xuICAgICAgbGV0IHRvdGFsX2NvbHMgPSBbXVxuICAgICAgaWYob2RkYXRhSUQpe1xuICAgICAgICB0b3RhbF9jb2xzID0gdG90YWxfY29scy5jb25jYXQoZGlzdGluY3RfdmFsdWVfbGlzdHMobmV3X2RhdGFzZXRzW29kZGF0YUlEXSxEQVRBU0VUX0NPTFVNTlNbJ29kZGF0YSddWydpZCddKSlcbiAgICAgIH1cblxuICAgICAgaWYocG9pZGF0YUlEKXtcbiAgICAgICAgdG90YWxfY29scyA9IHRvdGFsX2NvbHMuY29uY2F0KGRpc3RpbmN0X3ZhbHVlX2xpc3RzKG5ld19kYXRhc2V0c1tvZGRhdGFJRF0sREFUQVNFVF9DT0xVTU5TWydvZGRhdGEnXVsnaWQnXSkpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHF1ZXJ5X2lkX2xpc3QgPSBfLnVuaXEodG90YWxfY29scylcblxuICAgICAgY29uc3QgcGFyYXMgPSB7XG4gICAgICAgIGF0eXBlOiBjb29yZHNNb2RpZnk/J2JhdGNobW9kJzonYmF0Y2hnZW4nLFxuICAgICAgICBlbmdpbmU6J2dvb2dsZScsXG4gICAgICAgIGxhbmc6J2phJyxcbiAgICAgICAgdG9rZW46YXBpa2V5LFxuICAgICAgICBwcmVjaXNpb246QUREUkVTU19MRVZFTF9ESUNUW2xldmVsXX1cblxuICAgICAgY29uc3QgYXBpX3RlbXBsYXRlID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGkvcXVlcnlpZD8nXG5cblxuXG4gICAgICBpZihxdWVyeV9pZF9saXN0Lmxlbmd0aCA9PT0gMCl7XG4gICAgICAgIHJldHVybiB7cmVzdWx0Om5ld19kYXRhc2V0cyxmbGFnOjF9XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdhcGkgcXVlcnkgbGlzdCB0YXNrIGhlcmUnKVxuICAgICAgLy9oZXJlIHRvIGRldGVybWluZSBmdXR1cmUgcHJvY2VzcyBpc3N1ZXNcbiAgICAgIHJldHVybiB7cmVzdWx0OmdldEFQSVF1ZXJ5TGlzdFRhc2tzKHF1ZXJ5X2lkX2xpc3QubWFwKHg9PntcbiAgICAgICAgY29uc3QgdXJsICA9IGFwaV90ZW1wbGF0ZSArIG5ldyBVUkxTZWFyY2hQYXJhbXMoey4uLnBhcmFzLC4uLntwbGFjZV9pZDp4fX0pLnRvU3RyaW5nKClcbiAgICAgICAgcmV0dXJuIHVybFxuICAgICAgfSksdmlzU3RhdGVBY3Rpb24sbmV3X2RhdGFzZXRzKSxmbGFnOjJ9XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vdG9kbzogaG93IHRvIG1ha2UgdGhlIGZpbGUgZG93bmxvYWRhYmxlP1xuICAvLyByZXR1cm4gZXhwb3J0RmlsdGVyaW5nUHJvY2VzcyhkYXRhc2V0cyxleHBvcnRTZXR0aW5nKVxuICByZXR1cm4ge3Jlc3VsdDpuZXdfZGF0YXNldHMsZmxhZzoxfVxuXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZF9kYXRhc2V0X2NvbHVtbnMoZGF0YXNldCxjb2x1bW5zLGRhdGFfdHlwZXMsdmFsdWVzLGlmX2V4aXN0cyl7XG5cbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVfZGF0YXNldF9jb2x1bW4oZGF0YXNldCxjb2x1bW4sdmFsdWVzKXtcblxuXG59XG5cblxuXG5cblxuXG4iXX0=